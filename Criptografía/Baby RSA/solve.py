# Import necessary libraries
import math
from Crypto.Util.number import long_to_bytes

# --- Read values from output.txt ---
# In a real scenario, you would read this from the file.
# For this example, I'll copy the values from the file content provided.

# Content from output.txt:
# e = 65537
# n = 9585121477950028234579203663094953030216305929763421195727703500398038416736286507259998179103501434359303083394565357086367895067474653110541990823362102030704414172138475104244437928078652537332438224029993167762766348278670949967062739109122461255002804041255888021409504660639048443171129863964805809053846200103312720165788250172915814412503445512740754013745870718315024615116848341494899390763013579413658351934921537803054607436387438709949403548740793391662908510392796541118036515889532279319484096711012486901623559322600522363050436830434359885330452604535500857670899389471994592156995354357960854926659
# ct = 2590329737905360274315589748425439312696455101069896642342444511999715178383441602964061492688333705489904425351663838839174351009835366296701925776675294540004289031636776526731371349590560594558571572227035021028166439434584745527900708165002639651117795330661391698184365435313873829676808773007393085894926725728428571555070626071368514941983606409428237864664060343692882355628504416246186863621312362153817271592007025617657835029948288773756634993693382182990508208164072383344394370990533764672835990488209946516840957018818267627916095694951270474480038203119354131308324877600708728745696122842915106370093
# leak = 987362744914200248444365515120712260859967347949910493751287493449954952860289456681889766306800130542420567609853094822649439856759435362428864388323494795689440245329346162243993343158993311627422847641750672759943358728125772595586817859334802288014618624203093787998741817469172889165443667333623175699293520653075968300631696028807673663992686492629903035917310579803929111416892036374175634383472987061907491643727162777407243731037629016651790144368129973127208887303705614588080009782637968745083945071933386932863916579926529951332097660199088390136322212864119323222514136987196729135234145431307704473137402602567718392266365869035196465213662711196099216699237321644072793356735940264824413077087834699915521540419733710954463757661353510661682127425324320628522218101868119211728549479286595721370671332656471888984856909026883628899586831866681605786842386298282087794682303927478017965701165663346181595982952

# Assign values (replace with file reading if running locally)
e = 65537
n = 9585121477950028234579203663094953030216305929763421195727703500398038416736286507259998179103501434359303083394565357086367895067474653110541990823362102030704414172138475104244437928078652537332438224029993167762766348278670949967062739109122461255002804041255888021409504660639048443171129863964805809053846200103312720165788250172915814412503445512740754013745870718315024615116848341494899390763013579413658351934921537803054607436387438709949403548740793391662908510392796541118036515889532279319484096711012486901623559322600522363050436830434359885330452604535500857670899389471994592156995354357960854926659
ct = 2590329737905360274315589748425439312696455101069896642342444511999715178383441602964061492688333705489904425351663838839174351009835366296701925776675294540004289031636776526731371349590560594558571572227035021028166439434584745527900708165002639651117795330661391698184365435313873829676808773007393085894926725728428571555070626071368514941983606409428237864664060343692882355628504416246186863621312362153817271592007025617657835029948288773756634993693382182990508208164072383344394370990533764672835990488209946516840957018818267627916095694951270474480038203119354131308324877600708728745696122842915106370093
leak = 987362744914200248444365515120712260859967347949910493751287493449954952860289456681889766306800130542420567609853094822649439856759435362428864388323494795689440245329346162243993343158993311627422847641750672759943358728125772595586817859334802288014618624203093787998741817469172889165443667333623175699293520653075968300631696028807673663992686492629903035917310579803929111416892036374175634383472987061907491643727162777407243731037629016651790144368129973127208887303705614588080009782637968745083945071933386932863916579926529951332097660199088390136322212864119323222514136987196729135234145431307704473137402602567718392266365869035196465213662711196099216699237321644072793356735940264824413077087834699915521540419733710954463757661353510661682127425324320628522218101868119211728549479286595721370671332656471888984856909026883628899586831866681605786842386298282087794682303927478017965701165663346181595982952

# --- Calculations ---

# 1. Calculate discriminant
print("[+] Calculating discriminant...")
delta = (n - 1)**2 - 4 * leak
print(f"  delta = {delta}")

# 2. Calculate integer square root
print("[+] Calculating integer square root of delta...")
sqrt_delta = math.isqrt(delta)
print(f"  sqrt_delta = {sqrt_delta}")

# 3. Check if delta is a perfect square
if sqrt_delta * sqrt_delta != delta:
    print("[-] Error: Delta is not a perfect square. Cannot proceed.")
    exit()
print("[+] Delta is a perfect square.")

# 4. Calculate potential p values
print("[+] Calculating potential p values...")
p1 = (n + 1 + sqrt_delta) // 2
p2 = (n + 1 - sqrt_delta) // 2
print(f"  Potential p1 = {p1}")
print(f"  Potential p2 = {p2}")

# 5. Find the correct p and calculate q
print("[+] Finding correct p and q...")
p = 0
q = 0
if n % p1 == 0:
    p = p1
    q = n // p1
    print(f"  Found p = p1")
elif n % p2 == 0:
    p = p2
    q = n // p2
    print(f"  Found p = p2")
else:
    print("[-] Error: Neither p1 nor p2 divides n. Check calculations.")
    exit()

print(f"  p = {p}")
print(f"  q = {q}")

# 6. Calculate phi
print("[+] Calculating phi...")
phi = (p - 1) * (q - 1)
print(f"  phi = {phi}")

# 7. Calculate private key d
print("[+] Calculating private key d...")
# Use pow(e, -1, phi) which is available in Python 3.8+ for modular inverse
try:
    d = pow(e, -1, phi)
    print(f"  d = {d}")
except ValueError:
    print("[-] Error: Modular inverse does not exist (e and phi are not coprime).")
    exit()


# 8. Decrypt the ciphertext
print("[+] Decrypting ciphertext...")
m = pow(ct, d, n)
print(f"  Decrypted message (long integer): {m}")

# 9. Convert message to flag
print("[+] Converting message to bytes...")
try:
    flag_bytes = long_to_bytes(m)
    flag_string = flag_bytes.decode('utf-8') # Assuming flag is utf-8 text
    print("\n[*] SUCCESS! Recovered Flag:")
    print(flag_string)
except Exception as error:
    print(f"[-] Error converting message to bytes or decoding: {error}")
    print("  Raw bytes:", flag_bytes)
